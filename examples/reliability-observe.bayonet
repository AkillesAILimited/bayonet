parameters{ NUM_PACKETS(3), NUM_ARRIVED(3), P_FAIL(1/1000) }

num_steps 30;

topology{
	nodes{ H0, H1, S0, S1, S2, S3 }
	links{
		(H0,pt1) <-> (S0,pt1),
		(S0,pt2) <-> (S1,pt1),
		(S0,pt3) <-> (S2,pt1),
		(S1,pt2) <-> (S3,pt1),
		(S2,pt2) <-> (S3,pt2),
		(S3,pt3) <-> (H1,pt1)
	}
}

programs{ H0 -> h0, H1 -> h1, S0 -> s0, S1 -> s1, S2 -> s2, S3 -> s3 }

query probability(num_arrived@H1 == NUM_ARRIVED); // q₁

query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 1); // q₂
query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 2); // q₃
query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 3); // q₄

query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 1 and failing@S2==0); // q₅
query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 1 and failing@S2==1); // q₆

query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 2 and failing@S2==0); // q₇
query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 2 and failing@S2==1); // q₈

query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 2 and failing@S2==0); // q₉
query probability(num_arrived@H1 == NUM_ARRIVED and strategy@S0 == 2 and failing@S2==1); // q₁₀


packet_fields{ id }

def h0(pkt,port) state pkt_count(0){
	new;
	if pkt_count < NUM_PACKETS+1 {
		new;
		pkt_count = pkt_count + 1;
		pkt.id = pkt_count;
		if pkt_count == 4{
			fwd(10); // terminal marker
		} else{
			fwd(1);
		}
	} else { drop; drop; }
}
def h1() state num_arrived(0){
	num_arrived = num_arrived + 1;
	if num_arrived == 1{
		// observe first packet
	}else if num_arrived == 2{
		// observe second packet
	}else if num_arrived == 3{
		// observe third packet
	}
	drop;
}
def s0() state strategy(4){
	if strategy == 4{
		strategy = uniformInt(1,2);
		if strategy == 2{
			strategy = strategy + flip(1/2);
		}
	}
	if strategy == 1{
		if flip(1/2){
			fwd(2);
		}else{
			fwd(3);
		}
	}else{
		fwd(strategy);
	}
}
def s1(){
	fwd(2);
}
def s2()state failing(2){
	if failing == 2 { failing = flip(P_FAIL); }
	if failing == 1 { drop }
	else{ fwd(2); }
}
def s3(){
	fwd(3);
}

def scheduler() state num_actions(0){
	actions := ([]: (R x R)[]);
	for i in [0..k){
		if (Q_in@i).size() > 0 { actions ~= [(RunSw,i)]; }
		if (Q_out@i).size() > 0 { actions ~= [(FwdQ,i)]; }
	}
	num_actions += 1;
	return actions[uniformInt(0,actions.length-1)];
}
